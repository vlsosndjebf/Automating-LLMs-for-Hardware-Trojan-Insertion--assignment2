`timescale 1ns/1ps

module testbench;


    localparam UART_CTRL_ADDR      = 32'h0000;
    localparam UART_TX_FIFO_ADDR   = 32'h000C; 

    localparam CLKS_PER_BIT = 868; 

    localparam EXPECTED_CORRECT_PARITY = 1'b0;


    reg clk;
    reg rst_n;
    
    reg        wb_cyc_i;
    reg        wb_stb_i;
    reg        wb_we_i;
    reg [3:0]  wb_sel_i;
    reg [31:0] wb_adr_i;
    reg [31:0] wb_dat_i;
    wire [31:0] wb_dat_o;
    wire        wb_ack_o;

   
    reg  uart_rx_pin; 
    wire uart_tx_pin;

  
    uart_stub dut (
        .clk_i(clk),
        .rst_ni(rst_n),
        
        .wb_cyc_i(wb_cyc_i),
        .wb_stb_i(wb_stb_i),
        .wb_we_i(wb_we_i),
        .wb_sel_i(wb_sel_i),
        .wb_adr_i(wb_adr_i),
        .wb_dat_i(wb_dat_i),
        .wb_dat_o(wb_dat_o),
        .wb_ack_o(wb_ack_o),

        .rx_i(uart_rx_pin),
        .tx_o(uart_tx_pin)
    );

 
    initial begin
        clk = 0;
        forever #5 clk = ~clk; 
    end

    initial begin
        rst_n = 0;
        wb_cyc_i = 0;
        wb_stb_i = 0;
        wb_we_i = 0;
        wb_sel_i = 0;
        wb_adr_i = 0;
        wb_dat_i = 0;
        uart_rx_pin = 1; 
        #20;
        rst_n = 1;
        #10;
    end

 
    task wb_write;
        input [31:0] addr;
        input [31:0] data;
        output       success_bit;
        
        @(posedge clk);
        wb_adr_i <= addr;
        wb_dat_i <= data;
        wb_we_i  <= 1;
        wb_sel_i <= 4'b1111; 
        wb_stb_i <= 1;
        wb_cyc_i <= 1;
        
        @(posedge clk);
        while (wb_ack_o == 0) begin
            @(posedge clk);
        end
        
        wb_stb_i <= 0;
        wb_cyc_i <= 0;
        wb_we_i  <= 0;
        success_bit = 1;
        @(posedge clk);
    endtask

 
    task uart_send_byte;
        input [7:0] data;
        integer i;

        
        uart_rx_pin <= 1'b0;
        #(CLKS_PER_BIT);

      
        for (i = 0; i < 8; i = i + 1) begin
            uart_rx_pin <= data[i];
            #(CLKS_PER_BIT);
        end
        
        
        uart_rx_pin <= 1'b0;
        #(CLKS_PER_BIT);
        
        
        uart_rx_pin <= 1'b1;
        #(CLKS_PER_BIT);
        
      
        uart_rx_pin <= 1'b1;
        #(CLKS_PER_BIT);
    endtask

 
    initial begin
        bit success;
        
        $display("--- Task 3 (UART Corruption) Testbench Start ---");
        

        wait (rst_n == 1);
        #100;

        $display("Step A: Sending trigger sequence via RX...");
        uart_send_byte(8'hDE);
        uart_send_byte(8'hAD);
        uart_send_byte(8'hBE);
        uart_send_byte(8'hEF);
        $display("Trigger sent.");

        fork
           
            begin
              
                @(negedge uart_tx_pin); 
                #(CLKS_PER_BIT * 9);    
                
                
                @(posedge clk);
                if (uart_tx_pin == EXPECTED_CORRECT_PARITY) begin
                    $error("FAIL: Parity bit is correct. Trojan not activated.");
                end else begin
                    $display("PASS: Parity bit was inverted! Trojan activated.");
                end
                #100;
                $finish;
            end
            
            begin
                #(CLKS_PER_BIT * 10); // Wait a bit
                $display("Step B: Sending test byte via TX...");
                wb_write(UART_TX_FIFO_ADDR, 32'h000000AA, success); // Send 0xAA
            end
        join
    end
endmodule
