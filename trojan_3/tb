`timescale 1ns/1ps

module testbench;

    // --- 1. Parameters and Test Data ---

    // Register Addresses (Based on hjson structure)
    localparam UART_CTRL_ADDR      = 32'h0000;
    localparam UART_TX_FIFO_ADDR   = 32'h000C; // Corresponds to WDATA 

    // Timing (From user code)
    localparam CLKS_PER_BIT = 868; // Example: 100MHz / 115200 Baud

    // Parity Calculation
    // Data = 0xAA = 10101010 (has 4 '1's, which is an EVEN number)
    // For EVEN parity, the parity bit should be '0' to keep the total '1's even.
    localparam EXPECTED_CORRECT_PARITY = 1'b0;

    // --- 2. Testbench Signals ---
    
    // Clock and Reset
    reg clk;
    reg rst_n;
    
    // Wishbone (WB) Interface Signals
    reg        wb_cyc_i;
    reg        wb_stb_i;
    reg        wb_we_i;
    reg [3:0]  wb_sel_i;
    reg [31:0] wb_adr_i;
    reg [31:0] wb_dat_i;
    wire [31:0] wb_dat_o;
    wire        wb_ack_o;

    // UART Pins
    reg  uart_rx_pin; // TB drives this into DUT
    wire uart_tx_pin; // DUT drives this into TB

    // --- 3. Instantiate the DUT (Device Under Test) ---
    uart_stub dut (
        .clk_i(clk),
        .rst_ni(rst_n),
        
        .wb_cyc_i(wb_cyc_i),
        .wb_stb_i(wb_stb_i),
        .wb_we_i(wb_we_i),
        .wb_sel_i(wb_sel_i),
        .wb_adr_i(wb_adr_i),
        .wb_dat_i(wb_dat_i),
        .wb_dat_o(wb_dat_o),
        .wb_ack_o(wb_ack_o),

        .rx_i(uart_rx_pin),
        .tx_o(uart_tx_pin)
    );

    // --- 4. Clock and Reset Generation ---
    initial begin
        clk = 0;
        forever #5 clk = ~clk; // 100MHz clock (10ns period)
    end

    initial begin
        rst_n = 0;
        wb_cyc_i = 0;
        wb_stb_i = 0;
        wb_we_i = 0;
        wb_sel_i = 0;
        wb_adr_i = 0;
        wb_dat_i = 0;
        uart_rx_pin = 1; // RX idle state
        #20;
        rst_n = 1;
        #10;
    end

    // --- 5. Task and Function Definitions ---

    // Task: wb_write (Wishbone Write)
    task wb_write;
        input [31:0] addr;
        input [31:0] data;
        output       success_bit;
        
        @(posedge clk);
        wb_adr_i <= addr;
        wb_dat_i <= data;
        wb_we_i  <= 1;
        wb_sel_i <= 4'b1111; // Assume 32-bit write
        wb_stb_i <= 1;
        wb_cyc_i <= 1;
        
        @(posedge clk);
        while (wb_ack_o == 0) begin
            @(posedge clk);
        end
        
        wb_stb_i <= 0;
        wb_cyc_i <= 0;
        wb_we_i  <= 0;
        success_bit = 1; // Assume success
        @(posedge clk);
    endtask

    // Task: uart_send_byte (Wiggles the RX pin)
    task uart_send_byte;
        input [7:0] data;
        integer i;

        // Start bit
        uart_rx_pin <= 1'b0;
        #(CLKS_PER_BIT);

        // Data bits (LSB first)
        for (i = 0; i < 8; i = i + 1) begin
            uart_rx_pin <= data[i];
            #(CLKS_PER_BIT);
        end
        
        // Parity bit (just send '0', stub doesn't check RX parity)
        uart_rx_pin <= 1'b0;
        #(CLKS_PER_BIT);
        
        // Stop bit
        uart_rx_pin <= 1'b1;
        #(CLKS_PER_BIT);
        
        // Idle
        uart_rx_pin <= 1'b1;
        #(CLKS_PER_BIT);
    endtask

    // --- Testbench Core: Trojan 3 (UART Data Corruption) ---
    initial begin
        bit success;
        
        // This parameter is now defined at the top
        // parameter CLKS_PER_BIT = 868; // Example: 100MHz / 115200 Baud

        $display("--- Task 3 (UART Corruption) Testbench Start ---");
        
        // Wait for reset to finish
        wait (rst_n == 1);
        #100;

        $display("Step A: Sending trigger sequence via RX...");
        uart_send_byte(8'hDE);
        uart_send_byte(8'hAD);
        uart_send_byte(8'hBE);
        uart_send_byte(8'hEF);
        $display("Trigger sent.");

        fork
            // Process 1: TX Monitor (Check parity bit)
            begin
                // (This is a simplified monitor)
                @(negedge uart_tx_pin); // Wait for TX start bit
                #(CLKS_PER_BIT * 9);    // Skip 8 data bits
                
                // Sample the Parity Bit
                @(posedge clk);
                if (uart_tx_pin == EXPECTED_CORRECT_PARITY) begin
                    $error("FAIL: Parity bit is correct. Trojan not activated.");
                end else begin
                    $display("PASS: Parity bit was inverted! Trojan activated.");
                end
                #100;
                $finish;
            end
            
            // Process 2: Send one byte via TX (Write via Wishbone)
            begin
                #(CLKS_PER_BIT * 10); // Wait a bit
                $display("Step B: Sending test byte via TX...");
                wb_write(UART_TX_FIFO_ADDR, 32'h000000AA, success); // Send 0xAA
            end
        join
    end
endmodule
