`timescale 1ns/1ps

module testbench;


    // Wishbone Addresses for the I2C Host Peripheral (from i2c.hjson)
    localparam I2C_HOST_CTRL_ADDR  = 32'h0000; 
    localparam I2C_HOST_STATUS_ADDR= 32'h0004; 
    localparam I2C_HOST_RDATA_ADDR = 32'h0008; 
    localparam I2C_HOST_FDATA_ADDR = 32'h000C; 
    
    
    localparam I2C_DEVICE_ADDR     = 7'h42;  
    
  
    localparam I2C_ADDR_TRIGGER = 8'h7F; 
    localparam I2C_DATA_REG     = 8'h10;
    
    reg clk;
    reg rst_n;
    
   
    reg        wb_cyc_i;
    reg        wb_stb_i;
    reg        wb_we_i;
    reg [3:0]  wb_sel_i;
    reg [31:0] wb_adr_i;
    reg [31:0] wb_dat_i;
    wire [31:0] wb_dat_o;
    wire        wb_ack_o;

   
    wire sda;
    wire scl;

    
    
    i2c_host_stub i2c_host (
        .clk_i(clk),
        .rst_ni(rst_n),
        
        .wb_cyc_i(wb_cyc_i),
        .wb_stb_i(wb_stb_i),
        .wb_we_i(wb_we_i),
        .wb_sel_i(wb_sel_i),
        .wb_adr_i(wb_adr_i),
        .wb_dat_i(wb_dat_i),
        .wb_dat_o(wb_dat_o),
        .wb_ack_o(wb_ack_o),
        
        .sda(sda),
        .scl(scl)
    );

   
    i2c_target_stub i2c_target_trojan (
        .clk_i(clk),
        .rst_ni(rst_n),
        .sda(sda),
        .scl(scl)
    );

    
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    initial begin
        rst_n = 0;
        wb_cyc_i = 0;
        wb_stb_i = 0;
        wb_we_i = 0;
        wb_sel_i = 0;
        wb_adr_i = 0;
        wb_dat_i = 0;
        #20;
        rst_n = 1;
        #10;
    end
    
    
   
    task wb_write;
        input [31:0] addr;
        input [31:0] data;
        output       success_bit;
        
        @(posedge clk);
        wb_adr_i <= addr;
        wb_dat_i <= data;
        wb_we_i  <= 1;
        wb_sel_i <= 4'b1111;
        wb_stb_i <= 1;
        wb_cyc_i <= 1;
        
        @(posedge clk);
        while (wb_ack_o == 0) @(posedge clk);
        
        wb_stb_i <= 0;
        wb_cyc_i <= 0;
        wb_we_i  <= 0;
        success_bit = 1;
        @(posedge clk);
    endtask

    task wb_read;
        input [31:0]  addr;
        output [31:0] data;
        output        success_bit;
        
        @(posedge clk);
        wb_adr_i <= addr;
        wb_we_i  <= 0;
        wb_sel_i <= 4'b1111;
        wb_stb_i <= 1;
        wb_cyc_i <= 1;
        
        @(posedge clk);
        while (wb_ack_o == 0) @(posedge clk);
        
        data = wb_dat_o;
        wb_stb_i <= 0;
        wb_cyc_i <= 0;
        success_bit = 1;
        @(posedge clk);
    endtask

    
    task i2c_wait_idle;
        reg [31:0] status_val;
        reg success;
        
        // Wait for HOSTIDLE bit to be 1 [cite: 166]
        do begin
            #(100);
            wb_read(I2C_HOST_STATUS_ADDR, status_val, success);
        end while (status_val[3] == 0); // Loop while Host is not idle
    endtask

   
    task i2c_write_transaction;
        input [7:0] reg_addr; 
        input [7:0] data;     
        reg success;
        
       
        wb_write(I2C_HOST_FDATA_ADDR, {23'h0, 1'b1, {I2C_DEVICE_ADDR, 1'b0}}, success);

       
        wb_write(I2C_HOST_FDATA_ADDR, {24'h0, reg_addr}, success);
        
       
        wb_write(I2C_HOST_FDATA_ADDR, {22'h0, 1'b1, 1'b0, data}, success);
        
        i2c_wait_idle();
    endtask

    
    task i2c_read_transaction;
        input [7:0]  reg_addr;  
        output [31:0] read_val; 
        reg success;

     
        wb_write(I2C_HOST_FDATA_ADDR, {23'h0, 1'b1, {I2C_DEVICE_ADDR, 1'b0}}, success);
        wb_write(I2C_HOST_FDATA_ADDR, {24'h0, reg_addr}, success);
        
      
        wb_write(I2C_HOST_FDATA_ADDR, {23'h0, 1'b1, {I2C_DEVICE_ADDR, 1'b1}}, success);
        
      
        wb_write(I2C_HOST_FDATA_ADDR, {21'h0, 1'b1, 1'b1, 1'b0, 8'd1}, success);

        i2c_wait_idle();

      
        wb_read(I2C_HOST_RDATA_ADDR, read_val, success);
    endtask


  
    initial begin
        bit success;
        [31:0] read_data;

       
        localparam I2C_ADDR_TRIGGER = 8'h7F; // (Register sub-address 0x7F)
        localparam I2C_DATA_REG     = 8'h10; // (Arbitrary data register sub-address)
        
        $display("--- Task 4 (I2C Substitution) Testbench Start ---");

        wait (rst_n == 1);
        #100;

       
        $display("Step A: Writing to I2C trigger address (0x%h)...", I2C_ADDR_TRIGGER);
    
        i2c_write_transaction(I2C_ADDR_TRIGGER, 8'h00);

     
        $display("Step B: Writing data 0xAB to reg 0x%h...", I2C_DATA_REG);
        i2c_write_transaction(I2C_DATA_REG, 8'hAB);
        
     
        $display("Step C: Reading back from reg 0x%h...", I2C_DATA_REG);
        i2c_read_transaction(I2C_DATA_REG, read_data);

        if (read_data[7:0] == 8'hBA) begin
            $display("PASS: Trojan activated! Data read back was 0xBA.");
        end else begin
            $error("FAIL: Trojan not activated. Data read back was %h", read_data[7:0]);
        end
        #100;
        $finish;
    end
endmodule
